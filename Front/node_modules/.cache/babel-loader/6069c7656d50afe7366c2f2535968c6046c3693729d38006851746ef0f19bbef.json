{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Deividas\\\\CC_Workspace\\\\lawander\\\\Front\\\\src\\\\pages\\\\Chat.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from \"react\";\nimport { MapContainer, TileLayer, Marker, Popup } from \"react-leaflet\";\nimport L from \"leaflet\";\nimport \"leaflet/dist/leaflet.css\";\nimport \"../css/chat.css\";\n\n// Fix for default markers in react-leaflet\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\ndelete L.Icon.Default.prototype._getIconUrl;\nL.Icon.Default.mergeOptions({\n  iconRetinaUrl: require(\"leaflet/dist/images/marker-icon-2x.png\"),\n  iconUrl: require(\"leaflet/dist/images/marker-icon.png\"),\n  shadowUrl: require(\"leaflet/dist/images/marker-shadow.png\")\n});\n\n// Create custom colored icons for different marker types\nconst createCustomIcon = (color, emoji = \"ğŸ“\") => {\n  return L.divIcon({\n    className: \"custom-marker\",\n    html: `\n      <div style=\"\n        background-color: ${color};\n        width: 25px;\n        height: 25px;\n        border-radius: 50% 50% 50% 0;\n        transform: rotate(-45deg);\n        border: 2px solid white;\n        box-shadow: 0 2px 4px rgba(0,0,0,0.3);\n        display: flex;\n        align-items: center;\n        justify-content: center;\n      \">\n        <div style=\"\n          transform: rotate(45deg);\n          color: white;\n          font-size: 12px;\n          font-weight: bold;\n        \">${emoji}</div>\n      </div>\n    `,\n    iconSize: [25, 25],\n    iconAnchor: [12, 24],\n    popupAnchor: [0, -24]\n  });\n};\n\n// Color scheme for different place types\nconst getMarkerColor = (placeType, placeName) => {\n  const name = placeName.toLowerCase();\n  if (placeType === \"destination\") {\n    return {\n      color: \"#ff69b4\",\n      emoji: \"ğŸ™ï¸\"\n    }; // Pink for destination\n  }\n\n  // Check for specific place categories\n  if (name.includes(\"museum\") || name.includes(\"gallery\") || name.includes(\"castle\") || name.includes(\"exhibition\")\n  //\n  ) {\n    return {\n      color: \"#8B4513\",\n      emoji: \"ğŸ›ï¸\"\n    }; // Brown for museums\n  }\n  if (name.includes(\"restaurant\") || name.includes(\"cafe\") || name.includes(\"bar\") || name.includes(\"food\") || name.includes(\"dining\") || name.includes(\"kitchen\") || name.includes(\"pub\") || name.includes(\"grille\") || name.includes(\"grill\") || name.includes(\"club\")) {\n    return {\n      color: \"#DC143C\",\n      emoji: \"ğŸ½ï¸\"\n    }; // Red for restaurants\n  }\n  if (name.includes(\"hotel\") || name.includes(\"accommodation\") || name.includes(\"hostel\") || name.includes(\"resort\") || name.includes(\"lodge\")) {\n    return {\n      color: \"#4169E1\",\n      emoji: \"ğŸ¨\"\n    }; // Royal blue for hotels\n  }\n  if (name.includes(\"park\") || name.includes(\"garden\") || name.includes(\"nature\") || name.includes(\"forest\") || name.includes(\"beach\")) {\n    return {\n      color: \"#228B22\",\n      emoji: \"ğŸŒ³\"\n    }; // Forest green for parks/nature\n  }\n  if (name.includes(\"church\") || name.includes(\"cathedral\") || name.includes(\"temple\") || name.includes(\"monastery\") || name.includes(\"mosque\") || name.includes(\"synagogue\")) {\n    return {\n      color: \"#9370DB\",\n      emoji: \"â›ª\"\n    }; // Purple for religious sites\n  }\n  if (name.includes(\"shop\") || name.includes(\"market\") || name.includes(\"mall\") || name.includes(\"store\") || name.includes(\"boutique\")) {\n    return {\n      color: \"#FF8C00\",\n      emoji: \"ğŸ›ï¸\"\n    }; // Orange for shopping\n  }\n  if (name.includes(\"theater\") || name.includes(\"cinema\") || name.includes(\"concert\") || name.includes(\"show\") || name.includes(\"entertainment\")) {\n    return {\n      color: \"#FF1493\",\n      emoji: \"ğŸ­\"\n    }; // Deep pink for entertainment\n  }\n\n  // Default color for other attractions\n  return {\n    color: \"#1E90FF\",\n    emoji: \"ğŸ¯\"\n  }; // Dodger blue for general attractions\n};\n\n// Generate specific description for popup\nconst getPlaceDescription = (placeName, fullAddress) => {\n  var _addressParts, _addressParts2, _addressParts$;\n  const name = placeName.toLowerCase();\n\n  // Extract city and street info from the full address\n  const addressParts = fullAddress.split(\",\");\n  const city = ((_addressParts = addressParts[addressParts.length - 3]) === null || _addressParts === void 0 ? void 0 : _addressParts.trim()) || ((_addressParts2 = addressParts[addressParts.length - 2]) === null || _addressParts2 === void 0 ? void 0 : _addressParts2.trim()) || \"Unknown\";\n  const street = ((_addressParts$ = addressParts[0]) === null || _addressParts$ === void 0 ? void 0 : _addressParts$.trim()) || \"\";\n\n  // Generate specific description based on place type and name\n  if (name.includes(\"museum\") || name.includes(\"gallery\") || name.includes(\"exhibition\")) {\n    if (name.includes(\"art\")) {\n      return `ğŸ›ï¸ <strong>${placeName}</strong><br>Art museum featuring local and international collections in ${city}`;\n    } else if (name.includes(\"history\") || name.includes(\"historical\")) {\n      return `ğŸ›ï¸ <strong>${placeName}</strong><br>Historical museum showcasing ${city}'s rich heritage and culture`;\n    } else if (name.includes(\"science\") || name.includes(\"natural\")) {\n      return `ğŸ›ï¸ <strong>${placeName}</strong><br>Science museum with interactive exhibits and natural history displays`;\n    } else {\n      return `ğŸ›ï¸ <strong>${placeName}</strong><br>Cultural institution featuring art, history, and science exhibits in ${city}`;\n    }\n  }\n  if (name.includes(\"restaurant\") || name.includes(\"cafe\") || name.includes(\"bar\") || name.includes(\"food\") || name.includes(\"dining\") || name.includes(\"kitchen\")) {\n    if (name.includes(\"cafe\") || name.includes(\"coffee\")) {\n      return `â˜• <strong>${placeName}</strong><br>Cozy cafe perfect for coffee, light meals, and relaxation in ${city}`;\n    } else if (name.includes(\"bar\") || name.includes(\"pub\")) {\n      return `ğŸº <strong>${placeName}</strong><br>Local bar/pub offering drinks and traditional ${city} atmosphere`;\n    } else {\n      return `ğŸ½ï¸ <strong>${placeName}</strong><br>Restaurant serving local cuisine and specialties in ${city}`;\n    }\n  }\n  if (name.includes(\"hotel\") || name.includes(\"accommodation\") || name.includes(\"hostel\") || name.includes(\"resort\") || name.includes(\"lodge\")) {\n    if (name.includes(\"hostel\")) {\n      return `ğŸ¨ <strong>${placeName}</strong><br>Budget-friendly hostel accommodation in the heart of ${city}`;\n    } else if (name.includes(\"resort\")) {\n      return `ğŸ¨ <strong>${placeName}</strong><br>Luxury resort with amenities and services in ${city}`;\n    } else {\n      return `ğŸ¨ <strong>${placeName}</strong><br>Hotel accommodation offering comfort and convenience in ${city}`;\n    }\n  }\n  if (name.includes(\"park\") || name.includes(\"garden\") || name.includes(\"nature\") || name.includes(\"forest\") || name.includes(\"beach\")) {\n    if (name.includes(\"botanical\") || name.includes(\"garden\")) {\n      return `ğŸŒ³ <strong>${placeName}</strong><br>Botanical garden featuring diverse plant collections and peaceful walking paths`;\n    } else if (name.includes(\"national\") || name.includes(\"forest\")) {\n      return `ğŸŒ² <strong>${placeName}</strong><br>National park with hiking trails and natural beauty`;\n    } else if (name.includes(\"beach\")) {\n      return `ğŸ–ï¸ <strong>${placeName}</strong><br>Beautiful beach area perfect for relaxation and water activities`;\n    } else {\n      return `ğŸŒ³ <strong>${placeName}</strong><br>Public park offering green spaces and recreational activities in ${city}`;\n    }\n  }\n  if (name.includes(\"church\") || name.includes(\"cathedral\") || name.includes(\"temple\") || name.includes(\"mosque\") || name.includes(\"synagogue\")) {\n    if (name.includes(\"cathedral\")) {\n      return `â›ª <strong>${placeName}</strong><br>Historic cathedral with stunning architecture and religious significance`;\n    } else if (name.includes(\"temple\")) {\n      return `ğŸ•‰ï¸ <strong>${placeName}</strong><br>Sacred temple representing spiritual heritage in ${city}`;\n    } else {\n      return `â›ª <strong>${placeName}</strong><br>Historic church with cultural and architectural importance`;\n    }\n  }\n  if (name.includes(\"shop\") || name.includes(\"market\") || name.includes(\"mall\") || name.includes(\"store\") || name.includes(\"boutique\")) {\n    if (name.includes(\"market\")) {\n      return `ğŸ›’ <strong>${placeName}</strong><br>Local market offering fresh produce and traditional goods`;\n    } else if (name.includes(\"boutique\")) {\n      return `ğŸ‘— <strong>${placeName}</strong><br>Boutique shop featuring unique fashion and local crafts`;\n    } else {\n      return `ğŸ›ï¸ <strong>${placeName}</strong><br>Shopping destination for local goods and souvenirs in ${city}`;\n    }\n  }\n  if (name.includes(\"theater\") || name.includes(\"cinema\") || name.includes(\"concert\") || name.includes(\"show\") || name.includes(\"entertainment\")) {\n    if (name.includes(\"theater\") || name.includes(\"theatre\")) {\n      return `ğŸ­ <strong>${placeName}</strong><br>Theater venue hosting plays, performances, and cultural events`;\n    } else if (name.includes(\"cinema\") || name.includes(\"movie\")) {\n      return `ğŸ¬ <strong>${placeName}</strong><br>Cinema showing latest films and cultural screenings`;\n    } else {\n      return `ğŸª <strong>${placeName}</strong><br>Entertainment venue for shows, concerts, and performances`;\n    }\n  }\n\n  // Default for other attractions - try to be more specific based on name\n  if (name.includes(\"castle\") || name.includes(\"fortress\")) {\n    return `ğŸ° <strong>${placeName}</strong><br>Historic castle/fortress with rich history and architectural beauty`;\n  } else if (name.includes(\"tower\") || name.includes(\"monument\")) {\n    return `ğŸ—¼ <strong>${placeName}</strong><br>Iconic landmark and monument representing ${city}'s heritage`;\n  } else if (name.includes(\"square\") || name.includes(\"plaza\")) {\n    return `ğŸ›ï¸ <strong>${placeName}</strong><br>Historic square/plaza in the heart of ${city}`;\n  } else {\n    return `ğŸ¯ <strong>${placeName}</strong><br>Notable attraction worth visiting during your time in ${city}`;\n  }\n};\nfunction Chat({\n  destination,\n  days,\n  onBackToWelcome\n}) {\n  _s();\n  const [messages, setMessages] = useState([]);\n  const [inputMessage, setInputMessage] = useState(\"\");\n  const [mapCenter, setMapCenter] = useState([51.505, -0.09]); // Default to London\n  const [markers, setMarkers] = useState([]);\n  const messagesEndRef = React.useRef(null);\n  const itineraryRunRef = React.useRef(\"\");\n  const scrollToBottom = () => {\n    var _messagesEndRef$curre;\n    (_messagesEndRef$curre = messagesEndRef.current) === null || _messagesEndRef$curre === void 0 ? void 0 : _messagesEndRef$curre.scrollIntoView({\n      behavior: \"smooth\"\n    });\n  };\n\n  // Extract place names from text (format: **PlaceName**)\n  const extractPlaceNames = text => {\n    console.log(\"Extracting place names from text:\", text);\n    const regex = /\\*\\*(.*?)\\*\\*/g;\n    const matches = [];\n    let match;\n    while ((match = regex.exec(text)) !== null) {\n      matches.push(match[1].trim());\n    }\n    console.log(\"Found matches:\", matches);\n    return matches;\n  };\n\n  // Extract place descriptions from AI response text\n  const extractPlaceDescriptions = (text, placeNames) => {\n    const descriptions = {};\n\n    // Split text into sentences for better parsing\n    const sentences = text.split(/[.!?]+/).map(s => s.trim()).filter(s => s.length > 0);\n    placeNames.forEach(placeName => {\n      // Look for sentences that mention this place\n      const relevantSentences = sentences.filter(sentence => sentence.toLowerCase().includes(placeName.toLowerCase()));\n      if (relevantSentences.length > 0) {\n        // Take the first relevant sentence and clean it up\n        let description = relevantSentences[0];\n\n        // Remove the place name from the beginning if it's there\n        description = description.replace(new RegExp(`\\\\*\\\\*${placeName}\\\\*\\\\*`, \"gi\"), \"\").trim();\n\n        // Remove colons from the description\n        description = description.replace(/:/g, \"\");\n\n        // Remove common prefixes\n        description = description.replace(/^(is|are|was|were|has|have|had|will|would|can|could|should|may|might)\\s+/i, \"\");\n\n        // Capitalize first letter\n        description = description.charAt(0).toUpperCase() + description.slice(1);\n\n        // Use the entire first sentence (no length limit)\n        descriptions[placeName] = description;\n      }\n    });\n    console.log(\"Extracted place descriptions:\", descriptions);\n    return descriptions;\n  };\n\n  // Format message text to highlight only found place names (case-insensitive)\n  const formatMessageText = (text, foundPlaces = []) => {\n    if (foundPlaces.length === 0) {\n      // If no places were found, don't highlight any\n      return text.replace(/\\*\\*(.*?)\\*\\*/g, \"$1\");\n    }\n\n    // Only highlight places that were actually found on the map (case-insensitive)\n    const foundLower = foundPlaces.map(p => p.toLowerCase());\n    return text.replace(/\\*\\*(.*?)\\*\\*/g, (match, placeName) => {\n      const trimmedPlaceName = placeName.trim();\n      if (foundLower.includes(trimmedPlaceName.toLowerCase())) {\n        return `<span class=\"place-name\">${placeName}</span>`;\n      } else {\n        return placeName; // Don't highlight if not found\n      }\n    });\n  };\n\n  // Format itinerary into HTML grouped by days, each item on a new line\n  const formatItineraryToHtml = rawText => {\n    if (!rawText) return \"\";\n    const normalized = rawText.replace(/\\r\\n/g, \"\\n\");\n    const lines = normalized.split(\"\\n\").map(l => l.replace(/^\\s*###\\s*/i, \"\").trim()); // remove leading ###\n\n    const daySections = [];\n    let current = null;\n    const dayHeaderRegex = /^#*\\s*day\\s*(\\d+)(?::|-)?\\s*(.*)$/i;\n    const pushCurrent = () => {\n      if (current) {\n        // Remove empty items\n        current.items = current.items.filter(i => i.trim().length > 0);\n        daySections.push(current);\n        current = null;\n      }\n    };\n    for (let rawLine of lines) {\n      if (!rawLine) continue;\n      // Remove leading bullet markers for both headers and items, e.g. \"* Day 1:\" or \"- Visit ...\"\n      let line = rawLine.replace(/^[-*â€¢]\\s*/, \"\").trim();\n      if (!line) continue;\n      const m = line.match(dayHeaderRegex);\n      if (m) {\n        pushCurrent();\n        const dayNum = m[1];\n        const rest = (m[2] || \"\").trim();\n        current = {\n          title: `Day ${dayNum}${rest ? `: ${rest}` : \"\"}`,\n          items: []\n        };\n        continue;\n      }\n      // Ignore preface lines before the first Day header\n      if (!current) continue;\n      // Treat bullet points or sentences as items\n      const cleaned = line.replace(/^[-*â€¢]\\s*/, \"\");\n      current.items.push(cleaned);\n    }\n    pushCurrent();\n    if (daySections.length === 0) {\n      return normalized.split(\"\\n\").filter(l => l.trim().length > 0).map(l => l.replace(/^\\s*###\\s*/i, \"\")).join(\"<br/>\");\n    }\n    const html = daySections.map(d => {\n      const itemsHtml = d.items.join(\"<br/>\");\n      return `<p style=\\\"margin: 0 0 14px 0;\\\"><strong>${d.title}</strong><br/>${itemsHtml}</p>`;\n    }).join(\"\\n\");\n    return html;\n  };\n\n  // Geocode multiple places and add them to the map\n  const geocodePlaces = async (placeNames, placeDescriptions = {}) => {\n    console.log(\"Geocoding places:\", placeNames);\n    console.log(\"Place descriptions:\", placeDescriptions);\n    const newMarkers = [];\n    const foundPlaces = [];\n    for (const placeName of placeNames) {\n      try {\n        // Try multiple search strategies for better results, prioritizing local results\n        const searchQueries = [`${placeName}, ${destination}`,\n        // Name + destination city (highest priority)\n        `${placeName}, ${destination}, Lithuania`,\n        // Name + destination + country\n        `${placeName} ${destination}`,\n        // Name + destination (alternative format)\n        `${placeName}` // Original name (fallback only)\n        ];\n\n        // For museums, try alternative search terms with destination\n        if (placeName.toLowerCase().includes(\"museum\")) {\n          // Try without \"museum\" in the name\n          const nameWithoutMuseum = placeName.replace(/museum/gi, \"\").trim();\n          if (nameWithoutMuseum) {\n            searchQueries.push(`${nameWithoutMuseum}, ${destination}`);\n            searchQueries.push(`${nameWithoutMuseum} museum, ${destination}`);\n            searchQueries.push(`${nameWithoutMuseum}, ${destination}, Lithuania`);\n          }\n\n          // Try with just the main part of the name\n          const mainName = placeName.split(\":\")[0].split(\"(\")[0].trim();\n          if (mainName !== placeName) {\n            searchQueries.push(`${mainName}, ${destination}`);\n            searchQueries.push(`${mainName} museum, ${destination}`);\n            searchQueries.push(`${mainName}, ${destination}, Lithuania`);\n          }\n        }\n        let found = false;\n        for (const query of searchQueries) {\n          const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=3&addressdetails=1`);\n          const data = await response.json();\n          console.log(`Searching for \"${query}\":`, data.length, \"results\");\n          if (data && data.length > 0) {\n            // Filter results to only include those in the destination area\n            const localResults = data.filter(item => {\n              const address = item.display_name.toLowerCase();\n              const destinationLower = destination.toLowerCase();\n\n              // Must include the destination city name\n              const hasDestination = address.includes(destinationLower);\n\n              // Should also be in Lithuania (but destination is primary requirement)\n              const isInLithuania = address.includes(\"lithuania\") || address.includes(\"lt\");\n\n              // Prioritize results that have both destination and Lithuania\n              return hasDestination && isInLithuania;\n            });\n\n            // If we have local results, use them; otherwise use all results but with warning\n            const resultsToUse = localResults.length > 0 ? localResults : data;\n            if (localResults.length === 0) {\n              console.warn(`âš ï¸ No local results found for ${placeName} in ${destination}. Using first available result.`);\n            }\n\n            // Find the best match (prefer results with more address details)\n            const bestMatch = resultsToUse.find(item => item.display_name.toLowerCase().includes(placeName.toLowerCase()) || item.display_name.toLowerCase().includes(destination.toLowerCase())) || resultsToUse[0];\n            const {\n              lat,\n              lon,\n              display_name\n            } = bestMatch;\n            const coordinates = [parseFloat(lat), parseFloat(lon)];\n            newMarkers.push({\n              position: coordinates,\n              popup: `${placeName}<br><small>${display_name}</small>`,\n              type: \"place\",\n              placeName: placeName,\n              fullAddress: display_name,\n              aiDescription: placeDescriptions[placeName] || null\n            });\n            foundPlaces.push(placeName); // Add to found places list\n            console.log(`âœ… Found ${placeName} at:`, coordinates);\n            console.log(`   Full address: ${display_name}`);\n            found = true;\n            break; // Stop trying other queries once we find a match\n          }\n        }\n        if (!found) {\n          console.log(`âŒ No results found for: ${placeName}`);\n          console.log(`   Tried queries:`, searchQueries);\n\n          // Fallback: Try to find any museum in the destination city\n          if (placeName.toLowerCase().includes(\"museum\")) {\n            console.log(`ğŸ”„ Trying fallback search for museums in ${destination}`);\n            try {\n              const fallbackResponse = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=museum+${encodeURIComponent(destination)}+lithuania&limit=5&addressdetails=1`);\n              const fallbackData = await fallbackResponse.json();\n              if (fallbackData && fallbackData.length > 0) {\n                // Find a museum that hasn't been added yet\n                const availableMuseums = fallbackData.filter(museum => !newMarkers.some(marker => marker.popup.toLowerCase().includes(museum.display_name.toLowerCase().split(\",\")[0].toLowerCase())));\n                if (availableMuseums.length > 0) {\n                  const museum = availableMuseums[0];\n                  const coordinates = [parseFloat(museum.lat), parseFloat(museum.lon)];\n                  newMarkers.push({\n                    position: coordinates,\n                    popup: `${placeName} (${museum.display_name.split(\",\")[0]})<br><small>${museum.display_name}</small>`,\n                    type: \"place\",\n                    placeName: placeName,\n                    fullAddress: museum.display_name,\n                    aiDescription: placeDescriptions[placeName] || null\n                  });\n                  foundPlaces.push(placeName); // Add fallback found place to list\n                  console.log(`âœ… Fallback found: ${museum.display_name.split(\",\")[0]} at:`, coordinates);\n                }\n              }\n            } catch (fallbackError) {\n              console.error(`Fallback search failed for ${placeName}:`, fallbackError);\n            }\n          } else {\n            // General fallback: Try to find any place with similar name in the destination\n            console.log(`ğŸ”„ Trying general fallback search for ${placeName} in ${destination}`);\n            try {\n              const generalFallbackResponse = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(placeName)}+${encodeURIComponent(destination)}+lithuania&limit=3&addressdetails=1`);\n              const generalFallbackData = await generalFallbackResponse.json();\n              if (generalFallbackData && generalFallbackData.length > 0) {\n                // Filter for local results\n                const localFallbackResults = generalFallbackData.filter(item => {\n                  const address = item.display_name.toLowerCase();\n                  return address.includes(destination.toLowerCase()) && (address.includes(\"lithuania\") || address.includes(\"lt\"));\n                });\n                if (localFallbackResults.length > 0) {\n                  const fallbackItem = localFallbackResults[0];\n                  const coordinates = [parseFloat(fallbackItem.lat), parseFloat(fallbackItem.lon)];\n                  newMarkers.push({\n                    position: coordinates,\n                    popup: `${placeName}<br><small>${fallbackItem.display_name}</small>`,\n                    type: \"place\",\n                    placeName: placeName,\n                    fullAddress: fallbackItem.display_name,\n                    aiDescription: placeDescriptions[placeName] || null\n                  });\n                  foundPlaces.push(placeName);\n                  console.log(`âœ… Fallback found ${placeName} at:`, coordinates);\n                  console.log(`   Fallback address: ${fallbackItem.display_name}`);\n                }\n              }\n            } catch (generalFallbackError) {\n              console.error(`General fallback search failed for ${placeName}:`, generalFallbackError);\n            }\n          }\n        }\n\n        // Add small delay to avoid rate limiting\n        await new Promise(resolve => setTimeout(resolve, 200));\n      } catch (error) {\n        console.error(`Error geocoding ${placeName}:`, error);\n      }\n    }\n\n    // Add new markers to existing ones\n    if (newMarkers.length > 0) {\n      setMarkers(prev => [...prev, ...newMarkers]);\n      console.log(`âœ… Added ${newMarkers.length} new markers to map`);\n      console.log(`   Markers added:`, newMarkers.map(m => m.placeName));\n    } else {\n      console.log(\"âŒ No new markers were added\");\n    }\n\n    // Show which places were found vs not found\n    const notFoundPlaces = placeNames.filter(name => !foundPlaces.includes(name));\n    if (notFoundPlaces.length > 0) {\n      console.log(`âš ï¸ Places mentioned in chat but not found on map:`, notFoundPlaces);\n    }\n    console.log(\"âœ… Found places for highlighting:\", foundPlaces);\n    return foundPlaces;\n  };\n\n  // Geocode destination to get coordinates\n  const geocodeDestination = React.useCallback(async destinationName => {\n    try {\n      console.log(\"Geocoding destination:\", destinationName);\n      const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(destinationName)}&limit=1`);\n      const data = await response.json();\n      console.log(\"Geocoding response:\", data);\n      if (data && data.length > 0) {\n        const {\n          lat,\n          lon\n        } = data[0];\n        const coordinates = [parseFloat(lat), parseFloat(lon)];\n        console.log(\"Found coordinates:\", coordinates);\n\n        // Update map center to destination\n        setMapCenter(coordinates);\n\n        // Add destination marker\n        setMarkers([{\n          position: coordinates,\n          popup: `${destinationName} - Your destination for ${days} days`,\n          type: \"destination\",\n          placeName: destinationName,\n          fullAddress: `${destinationName}, ${data[0].display_name}`\n        }]);\n        return coordinates;\n      } else {\n        console.log(\"No results found for:\", destinationName);\n      }\n    } catch (error) {\n      console.error(\"Geocoding error:\", error);\n    }\n    return null;\n  }, [days]);\n  useEffect(() => {\n    // Geocode destination and update map\n    if (destination) {\n      geocodeDestination(destination);\n    }\n\n    // Generate an initial AI itinerary and place it above the welcome message\n    (async () => {\n      if (!destination || !days) return;\n      const runKey = `${String(destination).trim().toLowerCase()}|${String(days).trim()}`;\n      if (itineraryRunRef.current === runKey) {\n        console.log(\"â­ï¸ Skipping duplicate itinerary generation for\", runKey);\n        return;\n      }\n      itineraryRunRef.current = runKey;\n      try {\n        // Show a loading message at the top\n        setMessages([{\n          id: 0,\n          text: \"Generating your itinerary...\",\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString(),\n          isLoading: true\n        }]);\n        console.log(\"ğŸ”° Starting itinerary generation for\", destination, days);\n        const itineraryPrompt = `Create a concise, practical ${days}-day travel itinerary for ${destination}.\n\nREQUIREMENTS:\n- Only include places in or very near ${destination}\n- For every attraction, museum, park, restaurant, cafe, bar, etc., wrap the exact place name in **double asterisks** like **Exact Place Name**\n- Provide 3-6 items per day, with short descriptions (1 sentence each)\n- Mix of sights, food, and optional evening ideas where appropriate\n- No generic placeholders; use real places in ${destination}\n- Keep it compact and readable\n`;\n        const response = await fetch(\"http://localhost:8080/api/chat\", {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify({\n            message: itineraryPrompt\n          })\n        });\n        if (!response.ok) throw new Error(`HTTP error ${response.status}`);\n        const data = await response.json();\n\n        // Extract and geocode places from itinerary\n        const placeNames = extractPlaceNames(data.message);\n        const placeDescriptions = extractPlaceDescriptions(data.message, placeNames);\n        let foundPlaces = [];\n        if (placeNames.length > 0) {\n          foundPlaces = await geocodePlaces(placeNames, placeDescriptions);\n        }\n\n        // Replace loading with itinerary (formatted) followed by a single welcome message\n        const welcomeMessage = {\n          id: 1,\n          text: `Welcome! I'll help you plan your ${days}-day trip to ${destination}. What would you like to know about your destination?`,\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString(),\n          isWelcome: true\n        };\n        setMessages([{\n          id: 0,\n          text: `Here is a suggested ${days}-day itinerary for ${destination}:<br/><br/>${formatItineraryToHtml(data.message)}`,\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString(),\n          foundPlaces,\n          isItinerary: true\n        }, welcomeMessage]);\n      } catch (err) {\n        console.error(\"Failed to generate itinerary:\", err);\n        // Replace loading with an error notice and a single welcome message\n        const welcomeMessage = {\n          id: 1,\n          text: `Welcome! I'll help you plan your ${days}-day trip to ${destination}. What would you like to know about your destination?`,\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString(),\n          isWelcome: true\n        };\n        setMessages([{\n          id: 0,\n          text: \"Could not generate itinerary automatically. You can ask for suggestions in the chat.\",\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString()\n        }, welcomeMessage]);\n      }\n    })();\n  }, [destination, days, geocodeDestination]);\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages]);\n  const handleSendMessage = async e => {\n    e.preventDefault();\n    if (!inputMessage.trim()) return;\n    const newMessage = {\n      id: messages.length + 1,\n      text: inputMessage,\n      sender: \"user\",\n      timestamp: new Date().toLocaleTimeString()\n    };\n    setMessages([...messages, newMessage]);\n    const userMessage = inputMessage;\n    setInputMessage(\"\");\n\n    // Add loading message\n    const loadingMessage = {\n      id: messages.length + 2,\n      text: \"Lawander is thinking...\",\n      sender: \"ai\",\n      timestamp: new Date().toLocaleTimeString(),\n      isLoading: true\n    };\n    setMessages(prev => [...prev, loadingMessage]);\n    try {\n      // Add destination context to the message with more specific instructions\n      const contextualMessage = `Context: The user is planning a ${days}-day trip to ${destination}. \n\nIMPORTANT INSTRUCTIONS:\n- If the user asks for a specific type of place (restaurants, museums, hotels, etc.), ONLY provide places of that exact type\n- ALL places must be located in or very near ${destination}\n- When mentioning places, use the format **PlaceName** for each place\n- Be specific and accurate about locations - only include places that are actually in ${destination}\n- For each place you mention, provide a brief description (1-2 sentences) about what makes it special or what it offers\n- Include practical information like cuisine type, atmosphere, or unique features\n\nUser question: ${userMessage}`;\n\n      // Call backend API\n      const response = await fetch(\"http://localhost:8080/api/chat\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          message: contextualMessage\n        })\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n\n      // Extract place names from AI response (format: **PlaceName**)\n      const placeNames = extractPlaceNames(data.message);\n      console.log(\"AI Response:\", data.message);\n      console.log(\"Extracted place names:\", placeNames);\n\n      // Extract place descriptions from AI response\n      const placeDescriptions = extractPlaceDescriptions(data.message, placeNames);\n\n      // Geocode the places and add them to the map\n      let foundPlaces = [];\n      if (placeNames.length > 0) {\n        console.log(\"Starting geocoding for\", placeNames.length, \"places\");\n        foundPlaces = await geocodePlaces(placeNames, placeDescriptions);\n      } else {\n        console.log(\"No place names found in AI response\");\n      }\n\n      // Remove loading message and add real response\n      setMessages(prev => {\n        const withoutLoading = prev.filter(msg => !msg.isLoading);\n        const aiResponse = {\n          id: withoutLoading.length + 1,\n          text: data.message,\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString(),\n          foundPlaces: foundPlaces // Store found places for highlighting\n        };\n        return [...withoutLoading, aiResponse];\n      });\n    } catch (error) {\n      console.error(\"Error calling chat API:\", error);\n\n      // Remove loading message and add error response\n      setMessages(prev => {\n        const withoutLoading = prev.filter(msg => !msg.isLoading);\n        const errorResponse = {\n          id: withoutLoading.length + 1,\n          text: \"Sorry, I'm having trouble connecting to the server. Please try again later.\",\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString()\n        };\n        return [...withoutLoading, errorResponse];\n      });\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"chat-app\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"chat-header\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"header-left\",\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"back-button\",\n          onClick: onBackToWelcome,\n          children: \"\\u2190 Back\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 959,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"h1\", {\n          className: \"chat-title\",\n          children: \"Lawander\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 962,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 958,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"trip-info\",\n        children: [/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"destination\",\n          children: destination\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 965,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"days\",\n          children: [days, \" days\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 966,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 964,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 957,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"chat-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"chat-window\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"messages-container\",\n          children: [messages.map(message => /*#__PURE__*/_jsxDEV(\"div\", {\n            className: `message ${message.sender === \"user\" ? \"user-message\" : \"ai-message\"}`,\n            children: /*#__PURE__*/_jsxDEV(\"div\", {\n              className: `message-content ${message.isLoading ? \"loading\" : \"\"} ${message.isItinerary ? \"itinerary\" : \"\"}`,\n              children: [/*#__PURE__*/_jsxDEV(\"p\", {\n                dangerouslySetInnerHTML: {\n                  __html: formatMessageText(message.text, message.foundPlaces)\n                }\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 983,\n                columnNumber: 19\n              }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n                className: \"message-time\",\n                children: message.timestamp\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 991,\n                columnNumber: 19\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 979,\n              columnNumber: 17\n            }, this)\n          }, message.id, false, {\n            fileName: _jsxFileName,\n            lineNumber: 974,\n            columnNumber: 15\n          }, this)), /*#__PURE__*/_jsxDEV(\"div\", {\n            ref: messagesEndRef\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 995,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 972,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"form\", {\n          className: \"message-form\",\n          onSubmit: handleSendMessage,\n          children: [/*#__PURE__*/_jsxDEV(\"input\", {\n            type: \"text\",\n            value: inputMessage,\n            onChange: e => setInputMessage(e.target.value),\n            placeholder: \"Ask about your destination...\",\n            className: \"message-input\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 999,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            type: \"submit\",\n            className: \"send-button\",\n            children: \"Send\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1006,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 998,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 971,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"map-container\",\n        children: /*#__PURE__*/_jsxDEV(MapContainer, {\n          center: mapCenter,\n          zoom: 13,\n          style: {\n            height: \"100%\",\n            width: \"100%\"\n          },\n          children: [/*#__PURE__*/_jsxDEV(TileLayer, {\n            attribution: \"\\xA9 <a href=\\\"https://www.openstreetmap.org/copyright\\\">OpenStreetMap</a> contributors\",\n            url: \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1019,\n            columnNumber: 13\n          }, this), markers.map((marker, index) => {\n            const colorInfo = getMarkerColor(marker.type, marker.placeName);\n\n            // Generate popup content\n            let popupContent;\n            if (marker.type === \"destination\") {\n              popupContent = `ğŸ™ï¸ <strong>${marker.placeName}</strong><br><small>Your destination for ${days} days</small>`;\n            } else {\n              // Use AI description if available, otherwise fall back to generated description\n              if (marker.aiDescription) {\n                popupContent = `${colorInfo.emoji} <strong>${marker.placeName}</strong><br>${marker.aiDescription}`;\n              } else {\n                const description = getPlaceDescription(marker.placeName, marker.fullAddress);\n                popupContent = description;\n              }\n            }\n            return /*#__PURE__*/_jsxDEV(Marker, {\n              position: marker.position,\n              icon: createCustomIcon(colorInfo.color, colorInfo.emoji),\n              children: /*#__PURE__*/_jsxDEV(Popup, {\n                children: /*#__PURE__*/_jsxDEV(\"div\", {\n                  dangerouslySetInnerHTML: {\n                    __html: popupContent\n                  }\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1050,\n                  columnNumber: 21\n                }, this)\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1049,\n                columnNumber: 19\n              }, this)\n            }, index, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1044,\n              columnNumber: 17\n            }, this);\n          })]\n        }, `${mapCenter[0]}-${mapCenter[1]}`, true, {\n          fileName: _jsxFileName,\n          lineNumber: 1013,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1012,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 970,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 956,\n    columnNumber: 5\n  }, this);\n}\n_s(Chat, \"xURYyxLoDA+Jt1A463DfrgGFNjQ=\");\n_c = Chat;\nexport default Chat;\nvar _c;\n$RefreshReg$(_c, \"Chat\");","map":{"version":3,"names":["React","useState","useEffect","MapContainer","TileLayer","Marker","Popup","L","jsxDEV","_jsxDEV","Icon","Default","prototype","_getIconUrl","mergeOptions","iconRetinaUrl","require","iconUrl","shadowUrl","createCustomIcon","color","emoji","divIcon","className","html","iconSize","iconAnchor","popupAnchor","getMarkerColor","placeType","placeName","name","toLowerCase","includes","getPlaceDescription","fullAddress","_addressParts","_addressParts2","_addressParts$","addressParts","split","city","length","trim","street","Chat","destination","days","onBackToWelcome","_s","messages","setMessages","inputMessage","setInputMessage","mapCenter","setMapCenter","markers","setMarkers","messagesEndRef","useRef","itineraryRunRef","scrollToBottom","_messagesEndRef$curre","current","scrollIntoView","behavior","extractPlaceNames","text","console","log","regex","matches","match","exec","push","extractPlaceDescriptions","placeNames","descriptions","sentences","map","s","filter","forEach","relevantSentences","sentence","description","replace","RegExp","charAt","toUpperCase","slice","formatMessageText","foundPlaces","foundLower","p","trimmedPlaceName","formatItineraryToHtml","rawText","normalized","lines","l","daySections","dayHeaderRegex","pushCurrent","items","i","rawLine","line","m","dayNum","rest","title","cleaned","join","d","itemsHtml","geocodePlaces","placeDescriptions","newMarkers","searchQueries","nameWithoutMuseum","mainName","found","query","response","fetch","encodeURIComponent","data","json","localResults","item","address","display_name","destinationLower","hasDestination","isInLithuania","resultsToUse","warn","bestMatch","find","lat","lon","coordinates","parseFloat","position","popup","type","aiDescription","fallbackResponse","fallbackData","availableMuseums","museum","some","marker","fallbackError","error","generalFallbackResponse","generalFallbackData","localFallbackResults","fallbackItem","generalFallbackError","Promise","resolve","setTimeout","prev","notFoundPlaces","geocodeDestination","useCallback","destinationName","runKey","String","id","sender","timestamp","Date","toLocaleTimeString","isLoading","itineraryPrompt","method","headers","body","JSON","stringify","message","ok","Error","status","welcomeMessage","isWelcome","isItinerary","err","handleSendMessage","e","preventDefault","newMessage","userMessage","loadingMessage","contextualMessage","withoutLoading","msg","aiResponse","errorResponse","children","onClick","fileName","_jsxFileName","lineNumber","columnNumber","dangerouslySetInnerHTML","__html","ref","onSubmit","value","onChange","target","placeholder","center","zoom","style","height","width","attribution","url","index","colorInfo","popupContent","icon","_c","$RefreshReg$"],"sources":["C:/Users/Deividas/CC_Workspace/lawander/Front/src/pages/Chat.jsx"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\r\nimport { MapContainer, TileLayer, Marker, Popup } from \"react-leaflet\";\r\nimport L from \"leaflet\";\r\nimport \"leaflet/dist/leaflet.css\";\r\nimport \"../css/chat.css\";\r\n\r\n// Fix for default markers in react-leaflet\r\ndelete L.Icon.Default.prototype._getIconUrl;\r\nL.Icon.Default.mergeOptions({\r\n  iconRetinaUrl: require(\"leaflet/dist/images/marker-icon-2x.png\"),\r\n  iconUrl: require(\"leaflet/dist/images/marker-icon.png\"),\r\n  shadowUrl: require(\"leaflet/dist/images/marker-shadow.png\"),\r\n});\r\n\r\n// Create custom colored icons for different marker types\r\nconst createCustomIcon = (color, emoji = \"ğŸ“\") => {\r\n  return L.divIcon({\r\n    className: \"custom-marker\",\r\n    html: `\r\n      <div style=\"\r\n        background-color: ${color};\r\n        width: 25px;\r\n        height: 25px;\r\n        border-radius: 50% 50% 50% 0;\r\n        transform: rotate(-45deg);\r\n        border: 2px solid white;\r\n        box-shadow: 0 2px 4px rgba(0,0,0,0.3);\r\n        display: flex;\r\n        align-items: center;\r\n        justify-content: center;\r\n      \">\r\n        <div style=\"\r\n          transform: rotate(45deg);\r\n          color: white;\r\n          font-size: 12px;\r\n          font-weight: bold;\r\n        \">${emoji}</div>\r\n      </div>\r\n    `,\r\n    iconSize: [25, 25],\r\n    iconAnchor: [12, 24],\r\n    popupAnchor: [0, -24],\r\n  });\r\n};\r\n\r\n// Color scheme for different place types\r\nconst getMarkerColor = (placeType, placeName) => {\r\n  const name = placeName.toLowerCase();\r\n\r\n  if (placeType === \"destination\") {\r\n    return { color: \"#ff69b4\", emoji: \"ğŸ™ï¸\" }; // Pink for destination\r\n  }\r\n\r\n  // Check for specific place categories\r\n  if (\r\n    name.includes(\"museum\") ||\r\n    name.includes(\"gallery\") ||\r\n    name.includes(\"castle\") ||\r\n    name.includes(\"exhibition\")\r\n    //\r\n  ) {\r\n    return { color: \"#8B4513\", emoji: \"ğŸ›ï¸\" }; // Brown for museums\r\n  }\r\n\r\n  if (\r\n    name.includes(\"restaurant\") ||\r\n    name.includes(\"cafe\") ||\r\n    name.includes(\"bar\") ||\r\n    name.includes(\"food\") ||\r\n    name.includes(\"dining\") ||\r\n    name.includes(\"kitchen\") ||\r\n    name.includes(\"pub\") ||\r\n    name.includes(\"grille\") ||\r\n    name.includes(\"grill\") ||\r\n    name.includes(\"club\")\r\n  ) {\r\n    return { color: \"#DC143C\", emoji: \"ğŸ½ï¸\" }; // Red for restaurants\r\n  }\r\n\r\n  if (\r\n    name.includes(\"hotel\") ||\r\n    name.includes(\"accommodation\") ||\r\n    name.includes(\"hostel\") ||\r\n    name.includes(\"resort\") ||\r\n    name.includes(\"lodge\")\r\n  ) {\r\n    return { color: \"#4169E1\", emoji: \"ğŸ¨\" }; // Royal blue for hotels\r\n  }\r\n\r\n  if (\r\n    name.includes(\"park\") ||\r\n    name.includes(\"garden\") ||\r\n    name.includes(\"nature\") ||\r\n    name.includes(\"forest\") ||\r\n    name.includes(\"beach\")\r\n  ) {\r\n    return { color: \"#228B22\", emoji: \"ğŸŒ³\" }; // Forest green for parks/nature\r\n  }\r\n\r\n  if (\r\n    name.includes(\"church\") ||\r\n    name.includes(\"cathedral\") ||\r\n    name.includes(\"temple\") ||\r\n    name.includes(\"monastery\") ||\r\n    name.includes(\"mosque\") ||\r\n    name.includes(\"synagogue\")\r\n  ) {\r\n    return { color: \"#9370DB\", emoji: \"â›ª\" }; // Purple for religious sites\r\n  }\r\n\r\n  if (\r\n    name.includes(\"shop\") ||\r\n    name.includes(\"market\") ||\r\n    name.includes(\"mall\") ||\r\n    name.includes(\"store\") ||\r\n    name.includes(\"boutique\")\r\n  ) {\r\n    return { color: \"#FF8C00\", emoji: \"ğŸ›ï¸\" }; // Orange for shopping\r\n  }\r\n\r\n  if (\r\n    name.includes(\"theater\") ||\r\n    name.includes(\"cinema\") ||\r\n    name.includes(\"concert\") ||\r\n    name.includes(\"show\") ||\r\n    name.includes(\"entertainment\")\r\n  ) {\r\n    return { color: \"#FF1493\", emoji: \"ğŸ­\" }; // Deep pink for entertainment\r\n  }\r\n\r\n  // Default color for other attractions\r\n  return { color: \"#1E90FF\", emoji: \"ğŸ¯\" }; // Dodger blue for general attractions\r\n};\r\n\r\n// Generate specific description for popup\r\nconst getPlaceDescription = (placeName, fullAddress) => {\r\n  const name = placeName.toLowerCase();\r\n\r\n  // Extract city and street info from the full address\r\n  const addressParts = fullAddress.split(\",\");\r\n  const city =\r\n    addressParts[addressParts.length - 3]?.trim() ||\r\n    addressParts[addressParts.length - 2]?.trim() ||\r\n    \"Unknown\";\r\n  const street = addressParts[0]?.trim() || \"\";\r\n\r\n  // Generate specific description based on place type and name\r\n  if (\r\n    name.includes(\"museum\") ||\r\n    name.includes(\"gallery\") ||\r\n    name.includes(\"exhibition\")\r\n  ) {\r\n    if (name.includes(\"art\")) {\r\n      return `ğŸ›ï¸ <strong>${placeName}</strong><br>Art museum featuring local and international collections in ${city}`;\r\n    } else if (name.includes(\"history\") || name.includes(\"historical\")) {\r\n      return `ğŸ›ï¸ <strong>${placeName}</strong><br>Historical museum showcasing ${city}'s rich heritage and culture`;\r\n    } else if (name.includes(\"science\") || name.includes(\"natural\")) {\r\n      return `ğŸ›ï¸ <strong>${placeName}</strong><br>Science museum with interactive exhibits and natural history displays`;\r\n    } else {\r\n      return `ğŸ›ï¸ <strong>${placeName}</strong><br>Cultural institution featuring art, history, and science exhibits in ${city}`;\r\n    }\r\n  }\r\n\r\n  if (\r\n    name.includes(\"restaurant\") ||\r\n    name.includes(\"cafe\") ||\r\n    name.includes(\"bar\") ||\r\n    name.includes(\"food\") ||\r\n    name.includes(\"dining\") ||\r\n    name.includes(\"kitchen\")\r\n  ) {\r\n    if (name.includes(\"cafe\") || name.includes(\"coffee\")) {\r\n      return `â˜• <strong>${placeName}</strong><br>Cozy cafe perfect for coffee, light meals, and relaxation in ${city}`;\r\n    } else if (name.includes(\"bar\") || name.includes(\"pub\")) {\r\n      return `ğŸº <strong>${placeName}</strong><br>Local bar/pub offering drinks and traditional ${city} atmosphere`;\r\n    } else {\r\n      return `ğŸ½ï¸ <strong>${placeName}</strong><br>Restaurant serving local cuisine and specialties in ${city}`;\r\n    }\r\n  }\r\n\r\n  if (\r\n    name.includes(\"hotel\") ||\r\n    name.includes(\"accommodation\") ||\r\n    name.includes(\"hostel\") ||\r\n    name.includes(\"resort\") ||\r\n    name.includes(\"lodge\")\r\n  ) {\r\n    if (name.includes(\"hostel\")) {\r\n      return `ğŸ¨ <strong>${placeName}</strong><br>Budget-friendly hostel accommodation in the heart of ${city}`;\r\n    } else if (name.includes(\"resort\")) {\r\n      return `ğŸ¨ <strong>${placeName}</strong><br>Luxury resort with amenities and services in ${city}`;\r\n    } else {\r\n      return `ğŸ¨ <strong>${placeName}</strong><br>Hotel accommodation offering comfort and convenience in ${city}`;\r\n    }\r\n  }\r\n\r\n  if (\r\n    name.includes(\"park\") ||\r\n    name.includes(\"garden\") ||\r\n    name.includes(\"nature\") ||\r\n    name.includes(\"forest\") ||\r\n    name.includes(\"beach\")\r\n  ) {\r\n    if (name.includes(\"botanical\") || name.includes(\"garden\")) {\r\n      return `ğŸŒ³ <strong>${placeName}</strong><br>Botanical garden featuring diverse plant collections and peaceful walking paths`;\r\n    } else if (name.includes(\"national\") || name.includes(\"forest\")) {\r\n      return `ğŸŒ² <strong>${placeName}</strong><br>National park with hiking trails and natural beauty`;\r\n    } else if (name.includes(\"beach\")) {\r\n      return `ğŸ–ï¸ <strong>${placeName}</strong><br>Beautiful beach area perfect for relaxation and water activities`;\r\n    } else {\r\n      return `ğŸŒ³ <strong>${placeName}</strong><br>Public park offering green spaces and recreational activities in ${city}`;\r\n    }\r\n  }\r\n\r\n  if (\r\n    name.includes(\"church\") ||\r\n    name.includes(\"cathedral\") ||\r\n    name.includes(\"temple\") ||\r\n    name.includes(\"mosque\") ||\r\n    name.includes(\"synagogue\")\r\n  ) {\r\n    if (name.includes(\"cathedral\")) {\r\n      return `â›ª <strong>${placeName}</strong><br>Historic cathedral with stunning architecture and religious significance`;\r\n    } else if (name.includes(\"temple\")) {\r\n      return `ğŸ•‰ï¸ <strong>${placeName}</strong><br>Sacred temple representing spiritual heritage in ${city}`;\r\n    } else {\r\n      return `â›ª <strong>${placeName}</strong><br>Historic church with cultural and architectural importance`;\r\n    }\r\n  }\r\n\r\n  if (\r\n    name.includes(\"shop\") ||\r\n    name.includes(\"market\") ||\r\n    name.includes(\"mall\") ||\r\n    name.includes(\"store\") ||\r\n    name.includes(\"boutique\")\r\n  ) {\r\n    if (name.includes(\"market\")) {\r\n      return `ğŸ›’ <strong>${placeName}</strong><br>Local market offering fresh produce and traditional goods`;\r\n    } else if (name.includes(\"boutique\")) {\r\n      return `ğŸ‘— <strong>${placeName}</strong><br>Boutique shop featuring unique fashion and local crafts`;\r\n    } else {\r\n      return `ğŸ›ï¸ <strong>${placeName}</strong><br>Shopping destination for local goods and souvenirs in ${city}`;\r\n    }\r\n  }\r\n\r\n  if (\r\n    name.includes(\"theater\") ||\r\n    name.includes(\"cinema\") ||\r\n    name.includes(\"concert\") ||\r\n    name.includes(\"show\") ||\r\n    name.includes(\"entertainment\")\r\n  ) {\r\n    if (name.includes(\"theater\") || name.includes(\"theatre\")) {\r\n      return `ğŸ­ <strong>${placeName}</strong><br>Theater venue hosting plays, performances, and cultural events`;\r\n    } else if (name.includes(\"cinema\") || name.includes(\"movie\")) {\r\n      return `ğŸ¬ <strong>${placeName}</strong><br>Cinema showing latest films and cultural screenings`;\r\n    } else {\r\n      return `ğŸª <strong>${placeName}</strong><br>Entertainment venue for shows, concerts, and performances`;\r\n    }\r\n  }\r\n\r\n  // Default for other attractions - try to be more specific based on name\r\n  if (name.includes(\"castle\") || name.includes(\"fortress\")) {\r\n    return `ğŸ° <strong>${placeName}</strong><br>Historic castle/fortress with rich history and architectural beauty`;\r\n  } else if (name.includes(\"tower\") || name.includes(\"monument\")) {\r\n    return `ğŸ—¼ <strong>${placeName}</strong><br>Iconic landmark and monument representing ${city}'s heritage`;\r\n  } else if (name.includes(\"square\") || name.includes(\"plaza\")) {\r\n    return `ğŸ›ï¸ <strong>${placeName}</strong><br>Historic square/plaza in the heart of ${city}`;\r\n  } else {\r\n    return `ğŸ¯ <strong>${placeName}</strong><br>Notable attraction worth visiting during your time in ${city}`;\r\n  }\r\n};\r\n\r\nfunction Chat({ destination, days, onBackToWelcome }) {\r\n  const [messages, setMessages] = useState([]);\r\n  const [inputMessage, setInputMessage] = useState(\"\");\r\n  const [mapCenter, setMapCenter] = useState([51.505, -0.09]); // Default to London\r\n  const [markers, setMarkers] = useState([]);\r\n  const messagesEndRef = React.useRef(null);\r\n  const itineraryRunRef = React.useRef(\"\");\r\n\r\n  const scrollToBottom = () => {\r\n    messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\r\n  };\r\n\r\n  // Extract place names from text (format: **PlaceName**)\r\n  const extractPlaceNames = (text) => {\r\n    console.log(\"Extracting place names from text:\", text);\r\n    const regex = /\\*\\*(.*?)\\*\\*/g;\r\n    const matches = [];\r\n    let match;\r\n    while ((match = regex.exec(text)) !== null) {\r\n      matches.push(match[1].trim());\r\n    }\r\n    console.log(\"Found matches:\", matches);\r\n    return matches;\r\n  };\r\n\r\n  // Extract place descriptions from AI response text\r\n  const extractPlaceDescriptions = (text, placeNames) => {\r\n    const descriptions = {};\r\n\r\n    // Split text into sentences for better parsing\r\n    const sentences = text\r\n      .split(/[.!?]+/)\r\n      .map((s) => s.trim())\r\n      .filter((s) => s.length > 0);\r\n\r\n    placeNames.forEach((placeName) => {\r\n      // Look for sentences that mention this place\r\n      const relevantSentences = sentences.filter((sentence) =>\r\n        sentence.toLowerCase().includes(placeName.toLowerCase())\r\n      );\r\n\r\n      if (relevantSentences.length > 0) {\r\n        // Take the first relevant sentence and clean it up\r\n        let description = relevantSentences[0];\r\n\r\n        // Remove the place name from the beginning if it's there\r\n        description = description\r\n          .replace(new RegExp(`\\\\*\\\\*${placeName}\\\\*\\\\*`, \"gi\"), \"\")\r\n          .trim();\r\n\r\n        // Remove colons from the description\r\n        description = description.replace(/:/g, \"\");\r\n\r\n        // Remove common prefixes\r\n        description = description.replace(\r\n          /^(is|are|was|were|has|have|had|will|would|can|could|should|may|might)\\s+/i,\r\n          \"\"\r\n        );\r\n\r\n        // Capitalize first letter\r\n        description =\r\n          description.charAt(0).toUpperCase() + description.slice(1);\r\n\r\n        // Use the entire first sentence (no length limit)\r\n        descriptions[placeName] = description;\r\n      }\r\n    });\r\n\r\n    console.log(\"Extracted place descriptions:\", descriptions);\r\n    return descriptions;\r\n  };\r\n\r\n  // Format message text to highlight only found place names (case-insensitive)\r\n  const formatMessageText = (text, foundPlaces = []) => {\r\n    if (foundPlaces.length === 0) {\r\n      // If no places were found, don't highlight any\r\n      return text.replace(/\\*\\*(.*?)\\*\\*/g, \"$1\");\r\n    }\r\n\r\n    // Only highlight places that were actually found on the map (case-insensitive)\r\n    const foundLower = foundPlaces.map((p) => p.toLowerCase());\r\n    return text.replace(/\\*\\*(.*?)\\*\\*/g, (match, placeName) => {\r\n      const trimmedPlaceName = placeName.trim();\r\n      if (foundLower.includes(trimmedPlaceName.toLowerCase())) {\r\n        return `<span class=\"place-name\">${placeName}</span>`;\r\n      } else {\r\n        return placeName; // Don't highlight if not found\r\n      }\r\n    });\r\n  };\r\n\r\n  // Format itinerary into HTML grouped by days, each item on a new line\r\n  const formatItineraryToHtml = (rawText) => {\r\n    if (!rawText) return \"\";\r\n    const normalized = rawText.replace(/\\r\\n/g, \"\\n\");\r\n    const lines = normalized\r\n      .split(\"\\n\")\r\n      .map((l) => l.replace(/^\\s*###\\s*/i, \"\").trim()); // remove leading ###\r\n\r\n    const daySections = [];\r\n    let current = null;\r\n    const dayHeaderRegex = /^#*\\s*day\\s*(\\d+)(?::|-)?\\s*(.*)$/i;\r\n\r\n    const pushCurrent = () => {\r\n      if (current) {\r\n        // Remove empty items\r\n        current.items = current.items.filter((i) => i.trim().length > 0);\r\n        daySections.push(current);\r\n        current = null;\r\n      }\r\n    };\r\n\r\n    for (let rawLine of lines) {\r\n      if (!rawLine) continue;\r\n      // Remove leading bullet markers for both headers and items, e.g. \"* Day 1:\" or \"- Visit ...\"\r\n      let line = rawLine.replace(/^[-*â€¢]\\s*/, \"\").trim();\r\n      if (!line) continue;\r\n      const m = line.match(dayHeaderRegex);\r\n      if (m) {\r\n        pushCurrent();\r\n        const dayNum = m[1];\r\n        const rest = (m[2] || \"\").trim();\r\n        current = {\r\n          title: `Day ${dayNum}${rest ? `: ${rest}` : \"\"}`,\r\n          items: [],\r\n        };\r\n        continue;\r\n      }\r\n      // Ignore preface lines before the first Day header\r\n      if (!current) continue;\r\n      // Treat bullet points or sentences as items\r\n      const cleaned = line.replace(/^[-*â€¢]\\s*/, \"\");\r\n      current.items.push(cleaned);\r\n    }\r\n    pushCurrent();\r\n\r\n    if (daySections.length === 0) {\r\n      return normalized\r\n        .split(\"\\n\")\r\n        .filter((l) => l.trim().length > 0)\r\n        .map((l) => l.replace(/^\\s*###\\s*/i, \"\"))\r\n        .join(\"<br/>\");\r\n    }\r\n\r\n    const html = daySections\r\n      .map((d) => {\r\n        const itemsHtml = d.items.join(\"<br/>\");\r\n        return `<p style=\\\"margin: 0 0 14px 0;\\\"><strong>${d.title}</strong><br/>${itemsHtml}</p>`;\r\n      })\r\n      .join(\"\\n\");\r\n    return html;\r\n  };\r\n\r\n  // Geocode multiple places and add them to the map\r\n  const geocodePlaces = async (placeNames, placeDescriptions = {}) => {\r\n    console.log(\"Geocoding places:\", placeNames);\r\n    console.log(\"Place descriptions:\", placeDescriptions);\r\n    const newMarkers = [];\r\n    const foundPlaces = [];\r\n\r\n    for (const placeName of placeNames) {\r\n      try {\r\n        // Try multiple search strategies for better results, prioritizing local results\r\n        const searchQueries = [\r\n          `${placeName}, ${destination}`, // Name + destination city (highest priority)\r\n          `${placeName}, ${destination}, Lithuania`, // Name + destination + country\r\n          `${placeName} ${destination}`, // Name + destination (alternative format)\r\n          `${placeName}`, // Original name (fallback only)\r\n        ];\r\n\r\n        // For museums, try alternative search terms with destination\r\n        if (placeName.toLowerCase().includes(\"museum\")) {\r\n          // Try without \"museum\" in the name\r\n          const nameWithoutMuseum = placeName.replace(/museum/gi, \"\").trim();\r\n          if (nameWithoutMuseum) {\r\n            searchQueries.push(`${nameWithoutMuseum}, ${destination}`);\r\n            searchQueries.push(`${nameWithoutMuseum} museum, ${destination}`);\r\n            searchQueries.push(\r\n              `${nameWithoutMuseum}, ${destination}, Lithuania`\r\n            );\r\n          }\r\n\r\n          // Try with just the main part of the name\r\n          const mainName = placeName.split(\":\")[0].split(\"(\")[0].trim();\r\n          if (mainName !== placeName) {\r\n            searchQueries.push(`${mainName}, ${destination}`);\r\n            searchQueries.push(`${mainName} museum, ${destination}`);\r\n            searchQueries.push(`${mainName}, ${destination}, Lithuania`);\r\n          }\r\n        }\r\n\r\n        let found = false;\r\n        for (const query of searchQueries) {\r\n          const response = await fetch(\r\n            `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(\r\n              query\r\n            )}&limit=3&addressdetails=1`\r\n          );\r\n          const data = await response.json();\r\n\r\n          console.log(`Searching for \"${query}\":`, data.length, \"results\");\r\n\r\n          if (data && data.length > 0) {\r\n            // Filter results to only include those in the destination area\r\n            const localResults = data.filter((item) => {\r\n              const address = item.display_name.toLowerCase();\r\n              const destinationLower = destination.toLowerCase();\r\n\r\n              // Must include the destination city name\r\n              const hasDestination = address.includes(destinationLower);\r\n\r\n              // Should also be in Lithuania (but destination is primary requirement)\r\n              const isInLithuania =\r\n                address.includes(\"lithuania\") || address.includes(\"lt\");\r\n\r\n              // Prioritize results that have both destination and Lithuania\r\n              return hasDestination && isInLithuania;\r\n            });\r\n\r\n            // If we have local results, use them; otherwise use all results but with warning\r\n            const resultsToUse = localResults.length > 0 ? localResults : data;\r\n\r\n            if (localResults.length === 0) {\r\n              console.warn(\r\n                `âš ï¸ No local results found for ${placeName} in ${destination}. Using first available result.`\r\n              );\r\n            }\r\n\r\n            // Find the best match (prefer results with more address details)\r\n            const bestMatch =\r\n              resultsToUse.find(\r\n                (item) =>\r\n                  item.display_name\r\n                    .toLowerCase()\r\n                    .includes(placeName.toLowerCase()) ||\r\n                  item.display_name\r\n                    .toLowerCase()\r\n                    .includes(destination.toLowerCase())\r\n              ) || resultsToUse[0];\r\n\r\n            const { lat, lon, display_name } = bestMatch;\r\n            const coordinates = [parseFloat(lat), parseFloat(lon)];\r\n\r\n            newMarkers.push({\r\n              position: coordinates,\r\n              popup: `${placeName}<br><small>${display_name}</small>`,\r\n              type: \"place\",\r\n              placeName: placeName,\r\n              fullAddress: display_name,\r\n              aiDescription: placeDescriptions[placeName] || null,\r\n            });\r\n\r\n            foundPlaces.push(placeName); // Add to found places list\r\n            console.log(`âœ… Found ${placeName} at:`, coordinates);\r\n            console.log(`   Full address: ${display_name}`);\r\n            found = true;\r\n            break; // Stop trying other queries once we find a match\r\n          }\r\n        }\r\n\r\n        if (!found) {\r\n          console.log(`âŒ No results found for: ${placeName}`);\r\n          console.log(`   Tried queries:`, searchQueries);\r\n\r\n          // Fallback: Try to find any museum in the destination city\r\n          if (placeName.toLowerCase().includes(\"museum\")) {\r\n            console.log(\r\n              `ğŸ”„ Trying fallback search for museums in ${destination}`\r\n            );\r\n            try {\r\n              const fallbackResponse = await fetch(\r\n                `https://nominatim.openstreetmap.org/search?format=json&q=museum+${encodeURIComponent(\r\n                  destination\r\n                )}+lithuania&limit=5&addressdetails=1`\r\n              );\r\n              const fallbackData = await fallbackResponse.json();\r\n\r\n              if (fallbackData && fallbackData.length > 0) {\r\n                // Find a museum that hasn't been added yet\r\n                const availableMuseums = fallbackData.filter(\r\n                  (museum) =>\r\n                    !newMarkers.some((marker) =>\r\n                      marker.popup\r\n                        .toLowerCase()\r\n                        .includes(\r\n                          museum.display_name\r\n                            .toLowerCase()\r\n                            .split(\",\")[0]\r\n                            .toLowerCase()\r\n                        )\r\n                    )\r\n                );\r\n\r\n                if (availableMuseums.length > 0) {\r\n                  const museum = availableMuseums[0];\r\n                  const coordinates = [\r\n                    parseFloat(museum.lat),\r\n                    parseFloat(museum.lon),\r\n                  ];\r\n\r\n                  newMarkers.push({\r\n                    position: coordinates,\r\n                    popup: `${placeName} (${museum.display_name.split(\",\")[0]\r\n                      })<br><small>${museum.display_name}</small>`,\r\n                    type: \"place\",\r\n                    placeName: placeName,\r\n                    fullAddress: museum.display_name,\r\n                    aiDescription: placeDescriptions[placeName] || null,\r\n                  });\r\n\r\n                  foundPlaces.push(placeName); // Add fallback found place to list\r\n                  console.log(\r\n                    `âœ… Fallback found: ${museum.display_name.split(\",\")[0]\r\n                    } at:`,\r\n                    coordinates\r\n                  );\r\n                }\r\n              }\r\n            } catch (fallbackError) {\r\n              console.error(\r\n                `Fallback search failed for ${placeName}:`,\r\n                fallbackError\r\n              );\r\n            }\r\n          } else {\r\n            // General fallback: Try to find any place with similar name in the destination\r\n            console.log(\r\n              `ğŸ”„ Trying general fallback search for ${placeName} in ${destination}`\r\n            );\r\n            try {\r\n              const generalFallbackResponse = await fetch(\r\n                `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(\r\n                  placeName\r\n                )}+${encodeURIComponent(\r\n                  destination\r\n                )}+lithuania&limit=3&addressdetails=1`\r\n              );\r\n              const generalFallbackData = await generalFallbackResponse.json();\r\n\r\n              if (generalFallbackData && generalFallbackData.length > 0) {\r\n                // Filter for local results\r\n                const localFallbackResults = generalFallbackData.filter(\r\n                  (item) => {\r\n                    const address = item.display_name.toLowerCase();\r\n                    return (\r\n                      address.includes(destination.toLowerCase()) &&\r\n                      (address.includes(\"lithuania\") || address.includes(\"lt\"))\r\n                    );\r\n                  }\r\n                );\r\n\r\n                if (localFallbackResults.length > 0) {\r\n                  const fallbackItem = localFallbackResults[0];\r\n                  const coordinates = [\r\n                    parseFloat(fallbackItem.lat),\r\n                    parseFloat(fallbackItem.lon),\r\n                  ];\r\n\r\n                  newMarkers.push({\r\n                    position: coordinates,\r\n                    popup: `${placeName}<br><small>${fallbackItem.display_name}</small>`,\r\n                    type: \"place\",\r\n                    placeName: placeName,\r\n                    fullAddress: fallbackItem.display_name,\r\n                    aiDescription: placeDescriptions[placeName] || null,\r\n                  });\r\n\r\n                  foundPlaces.push(placeName);\r\n                  console.log(\r\n                    `âœ… Fallback found ${placeName} at:`,\r\n                    coordinates\r\n                  );\r\n                  console.log(\r\n                    `   Fallback address: ${fallbackItem.display_name}`\r\n                  );\r\n                }\r\n              }\r\n            } catch (generalFallbackError) {\r\n              console.error(\r\n                `General fallback search failed for ${placeName}:`,\r\n                generalFallbackError\r\n              );\r\n            }\r\n          }\r\n        }\r\n\r\n        // Add small delay to avoid rate limiting\r\n        await new Promise((resolve) => setTimeout(resolve, 200));\r\n      } catch (error) {\r\n        console.error(`Error geocoding ${placeName}:`, error);\r\n      }\r\n    }\r\n\r\n    // Add new markers to existing ones\r\n    if (newMarkers.length > 0) {\r\n      setMarkers((prev) => [...prev, ...newMarkers]);\r\n      console.log(`âœ… Added ${newMarkers.length} new markers to map`);\r\n      console.log(\r\n        `   Markers added:`,\r\n        newMarkers.map((m) => m.placeName)\r\n      );\r\n    } else {\r\n      console.log(\"âŒ No new markers were added\");\r\n    }\r\n\r\n    // Show which places were found vs not found\r\n    const notFoundPlaces = placeNames.filter(\r\n      (name) => !foundPlaces.includes(name)\r\n    );\r\n    if (notFoundPlaces.length > 0) {\r\n      console.log(\r\n        `âš ï¸ Places mentioned in chat but not found on map:`,\r\n        notFoundPlaces\r\n      );\r\n    }\r\n\r\n    console.log(\"âœ… Found places for highlighting:\", foundPlaces);\r\n    return foundPlaces;\r\n  };\r\n\r\n  // Geocode destination to get coordinates\r\n  const geocodeDestination = React.useCallback(\r\n    async (destinationName) => {\r\n      try {\r\n        console.log(\"Geocoding destination:\", destinationName);\r\n        const response = await fetch(\r\n          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(\r\n            destinationName\r\n          )}&limit=1`\r\n        );\r\n        const data = await response.json();\r\n        console.log(\"Geocoding response:\", data);\r\n\r\n        if (data && data.length > 0) {\r\n          const { lat, lon } = data[0];\r\n          const coordinates = [parseFloat(lat), parseFloat(lon)];\r\n          console.log(\"Found coordinates:\", coordinates);\r\n\r\n          // Update map center to destination\r\n          setMapCenter(coordinates);\r\n\r\n          // Add destination marker\r\n          setMarkers([\r\n            {\r\n              position: coordinates,\r\n              popup: `${destinationName} - Your destination for ${days} days`,\r\n              type: \"destination\",\r\n              placeName: destinationName,\r\n              fullAddress: `${destinationName}, ${data[0].display_name}`,\r\n            },\r\n          ]);\r\n\r\n          return coordinates;\r\n        } else {\r\n          console.log(\"No results found for:\", destinationName);\r\n        }\r\n      } catch (error) {\r\n        console.error(\"Geocoding error:\", error);\r\n      }\r\n      return null;\r\n    },\r\n    [days]\r\n  );\r\n\r\n  useEffect(() => {\r\n    // Geocode destination and update map\r\n    if (destination) {\r\n      geocodeDestination(destination);\r\n    }\r\n\r\n    // Generate an initial AI itinerary and place it above the welcome message\r\n    (async () => {\r\n      if (!destination || !days) return;\r\n      const runKey = `${String(destination).trim().toLowerCase()}|${String(\r\n        days\r\n      ).trim()}`;\r\n      if (itineraryRunRef.current === runKey) {\r\n        console.log(\"â­ï¸ Skipping duplicate itinerary generation for\", runKey);\r\n        return;\r\n      }\r\n      itineraryRunRef.current = runKey;\r\n      try {\r\n        // Show a loading message at the top\r\n        setMessages([\r\n          {\r\n            id: 0,\r\n            text: \"Generating your itinerary...\",\r\n            sender: \"ai\",\r\n            timestamp: new Date().toLocaleTimeString(),\r\n            isLoading: true,\r\n          },\r\n        ]);\r\n\r\n        console.log(\"ğŸ”° Starting itinerary generation for\", destination, days);\r\n\r\n        const itineraryPrompt = `Create a concise, practical ${days}-day travel itinerary for ${destination}.\r\n\r\nREQUIREMENTS:\r\n- Only include places in or very near ${destination}\r\n- For every attraction, museum, park, restaurant, cafe, bar, etc., wrap the exact place name in **double asterisks** like **Exact Place Name**\r\n- Provide 3-6 items per day, with short descriptions (1 sentence each)\r\n- Mix of sights, food, and optional evening ideas where appropriate\r\n- No generic placeholders; use real places in ${destination}\r\n- Keep it compact and readable\r\n`;\r\n\r\n        const response = await fetch(\"http://localhost:8080/api/chat\", {\r\n          method: \"POST\",\r\n          headers: { \"Content-Type\": \"application/json\" },\r\n          body: JSON.stringify({ message: itineraryPrompt }),\r\n        });\r\n\r\n        if (!response.ok) throw new Error(`HTTP error ${response.status}`);\r\n        const data = await response.json();\r\n\r\n        // Extract and geocode places from itinerary\r\n        const placeNames = extractPlaceNames(data.message);\r\n        const placeDescriptions = extractPlaceDescriptions(\r\n          data.message,\r\n          placeNames\r\n        );\r\n\r\n        let foundPlaces = [];\r\n        if (placeNames.length > 0) {\r\n          foundPlaces = await geocodePlaces(placeNames, placeDescriptions);\r\n        }\r\n\r\n        // Replace loading with itinerary (formatted) followed by a single welcome message\r\n        const welcomeMessage = {\r\n          id: 1,\r\n          text: `Welcome! I'll help you plan your ${days}-day trip to ${destination}. What would you like to know about your destination?`,\r\n          sender: \"ai\",\r\n          timestamp: new Date().toLocaleTimeString(),\r\n          isWelcome: true,\r\n        };\r\n        setMessages([\r\n          {\r\n            id: 0,\r\n            text: `Here is a suggested ${days}-day itinerary for ${destination}:<br/><br/>${formatItineraryToHtml(\r\n              data.message\r\n            )}`,\r\n            sender: \"ai\",\r\n            timestamp: new Date().toLocaleTimeString(),\r\n            foundPlaces,\r\n            isItinerary: true,\r\n          },\r\n          welcomeMessage,\r\n        ]);\r\n      } catch (err) {\r\n        console.error(\"Failed to generate itinerary:\", err);\r\n        // Replace loading with an error notice and a single welcome message\r\n        const welcomeMessage = {\r\n          id: 1,\r\n          text: `Welcome! I'll help you plan your ${days}-day trip to ${destination}. What would you like to know about your destination?`,\r\n          sender: \"ai\",\r\n          timestamp: new Date().toLocaleTimeString(),\r\n          isWelcome: true,\r\n        };\r\n        setMessages([\r\n          {\r\n            id: 0,\r\n            text: \"Could not generate itinerary automatically. You can ask for suggestions in the chat.\",\r\n            sender: \"ai\",\r\n            timestamp: new Date().toLocaleTimeString(),\r\n          },\r\n          welcomeMessage,\r\n        ]);\r\n      }\r\n    })();\r\n  }, [destination, days, geocodeDestination]);\r\n\r\n  useEffect(() => {\r\n    scrollToBottom();\r\n  }, [messages]);\r\n\r\n  const handleSendMessage = async (e) => {\r\n    e.preventDefault();\r\n    if (!inputMessage.trim()) return;\r\n\r\n    const newMessage = {\r\n      id: messages.length + 1,\r\n      text: inputMessage,\r\n      sender: \"user\",\r\n      timestamp: new Date().toLocaleTimeString(),\r\n    };\r\n\r\n    setMessages([...messages, newMessage]);\r\n    const userMessage = inputMessage;\r\n    setInputMessage(\"\");\r\n\r\n    // Add loading message\r\n    const loadingMessage = {\r\n      id: messages.length + 2,\r\n      text: \"Lawander is thinking...\",\r\n      sender: \"ai\",\r\n      timestamp: new Date().toLocaleTimeString(),\r\n      isLoading: true,\r\n    };\r\n    setMessages((prev) => [...prev, loadingMessage]);\r\n\r\n    try {\r\n      // Add destination context to the message with more specific instructions\r\n      const contextualMessage = `Context: The user is planning a ${days}-day trip to ${destination}. \r\n\r\nIMPORTANT INSTRUCTIONS:\r\n- If the user asks for a specific type of place (restaurants, museums, hotels, etc.), ONLY provide places of that exact type\r\n- ALL places must be located in or very near ${destination}\r\n- When mentioning places, use the format **PlaceName** for each place\r\n- Be specific and accurate about locations - only include places that are actually in ${destination}\r\n- For each place you mention, provide a brief description (1-2 sentences) about what makes it special or what it offers\r\n- Include practical information like cuisine type, atmosphere, or unique features\r\n\r\nUser question: ${userMessage}`;\r\n\r\n      // Call backend API\r\n      const response = await fetch(\"http://localhost:8080/api/chat\", {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n        },\r\n        body: JSON.stringify({\r\n          message: contextualMessage,\r\n        }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n\r\n      const data = await response.json();\r\n\r\n      // Extract place names from AI response (format: **PlaceName**)\r\n      const placeNames = extractPlaceNames(data.message);\r\n      console.log(\"AI Response:\", data.message);\r\n      console.log(\"Extracted place names:\", placeNames);\r\n\r\n      // Extract place descriptions from AI response\r\n      const placeDescriptions = extractPlaceDescriptions(\r\n        data.message,\r\n        placeNames\r\n      );\r\n\r\n      // Geocode the places and add them to the map\r\n      let foundPlaces = [];\r\n      if (placeNames.length > 0) {\r\n        console.log(\"Starting geocoding for\", placeNames.length, \"places\");\r\n        foundPlaces = await geocodePlaces(placeNames, placeDescriptions);\r\n      } else {\r\n        console.log(\"No place names found in AI response\");\r\n      }\r\n\r\n      // Remove loading message and add real response\r\n      setMessages((prev) => {\r\n        const withoutLoading = prev.filter((msg) => !msg.isLoading);\r\n        const aiResponse = {\r\n          id: withoutLoading.length + 1,\r\n          text: data.message,\r\n          sender: \"ai\",\r\n          timestamp: new Date().toLocaleTimeString(),\r\n          foundPlaces: foundPlaces, // Store found places for highlighting\r\n        };\r\n        return [...withoutLoading, aiResponse];\r\n      });\r\n    } catch (error) {\r\n      console.error(\"Error calling chat API:\", error);\r\n\r\n      // Remove loading message and add error response\r\n      setMessages((prev) => {\r\n        const withoutLoading = prev.filter((msg) => !msg.isLoading);\r\n        const errorResponse = {\r\n          id: withoutLoading.length + 1,\r\n          text: \"Sorry, I'm having trouble connecting to the server. Please try again later.\",\r\n          sender: \"ai\",\r\n          timestamp: new Date().toLocaleTimeString(),\r\n        };\r\n        return [...withoutLoading, errorResponse];\r\n      });\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"chat-app\">\r\n      <div className=\"chat-header\">\r\n        <div className=\"header-left\">\r\n          <button className=\"back-button\" onClick={onBackToWelcome}>\r\n            â† Back\r\n          </button>\r\n          <h1 className=\"chat-title\">Lawander</h1>\r\n        </div>\r\n        <div className=\"trip-info\">\r\n          <span className=\"destination\">{destination}</span>\r\n          <span className=\"days\">{days} days</span>\r\n        </div>\r\n      </div>\r\n\r\n      <div className=\"chat-container\">\r\n        <div className=\"chat-window\">\r\n          <div className=\"messages-container\">\r\n            {messages.map((message) => (\r\n              <div\r\n                key={message.id}\r\n                className={`message ${message.sender === \"user\" ? \"user-message\" : \"ai-message\"\r\n                  }`}\r\n              >\r\n                <div\r\n                  className={`message-content ${message.isLoading ? \"loading\" : \"\"\r\n                    } ${message.isItinerary ? \"itinerary\" : \"\"}`}\r\n                >\r\n                  <p\r\n                    dangerouslySetInnerHTML={{\r\n                      __html: formatMessageText(\r\n                        message.text,\r\n                        message.foundPlaces\r\n                      ),\r\n                    }}\r\n                  ></p>\r\n                  <span className=\"message-time\">{message.timestamp}</span>\r\n                </div>\r\n              </div>\r\n            ))}\r\n            <div ref={messagesEndRef} />\r\n          </div>\r\n\r\n          <form className=\"message-form\" onSubmit={handleSendMessage}>\r\n            <input\r\n              type=\"text\"\r\n              value={inputMessage}\r\n              onChange={(e) => setInputMessage(e.target.value)}\r\n              placeholder=\"Ask about your destination...\"\r\n              className=\"message-input\"\r\n            />\r\n            <button type=\"submit\" className=\"send-button\">\r\n              Send\r\n            </button>\r\n          </form>\r\n        </div>\r\n\r\n        <div className=\"map-container\">\r\n          <MapContainer\r\n            key={`${mapCenter[0]}-${mapCenter[1]}`}\r\n            center={mapCenter}\r\n            zoom={13}\r\n            style={{ height: \"100%\", width: \"100%\" }}\r\n          >\r\n            <TileLayer\r\n              attribution='&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\r\n              url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\r\n            />\r\n            {markers.map((marker, index) => {\r\n              const colorInfo = getMarkerColor(marker.type, marker.placeName);\r\n\r\n              // Generate popup content\r\n              let popupContent;\r\n              if (marker.type === \"destination\") {\r\n                popupContent = `ğŸ™ï¸ <strong>${marker.placeName}</strong><br><small>Your destination for ${days} days</small>`;\r\n              } else {\r\n                // Use AI description if available, otherwise fall back to generated description\r\n                if (marker.aiDescription) {\r\n                  popupContent = `${colorInfo.emoji} <strong>${marker.placeName}</strong><br>${marker.aiDescription}`;\r\n                } else {\r\n                  const description = getPlaceDescription(\r\n                    marker.placeName,\r\n                    marker.fullAddress\r\n                  );\r\n                  popupContent = description;\r\n                }\r\n              }\r\n\r\n              return (\r\n                <Marker\r\n                  key={index}\r\n                  position={marker.position}\r\n                  icon={createCustomIcon(colorInfo.color, colorInfo.emoji)}\r\n                >\r\n                  <Popup>\r\n                    <div dangerouslySetInnerHTML={{ __html: popupContent }} />\r\n                  </Popup>\r\n                </Marker>\r\n              );\r\n            })}\r\n          </MapContainer>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Chat;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}